<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Cutscene Module</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Apple SD Gothic Neo', sans-serif; user-select: none; }
        
        /* [컷신 컨테이너] 화면 전체를 덮음 */
        #cutscene-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            display: flex; flex-direction: column; justify-content: flex-end;
            transition: background-image 0.5s ease-in-out;
        }

        /* [캐릭터 스탠딩] */
        .standing-area {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* 클릭 통과 */
            display: flex; justify-content: center; align-items: flex-end;
        }
        .char-img {
            height: 80%; /* 화면 높이의 80% */
            max-width: 400px;
            object-fit: contain;
            transition: 0.3s;
            filter: brightness(0.6); /* 말 안할 땐 어둡게 */
            transform: scale(0.95);
        }
        .char-img.speaking {
            filter: brightness(1); /* 말할 땐 밝게 */
            transform: scale(1);
            z-index: 10;
        }
        /* 위치 클래스 */
        .pos-left { position: absolute; left: 5%; bottom: 0; }
        .pos-right { position: absolute; right: 5%; bottom: 0; }
        .pos-center { position: absolute; left: 50%; transform: translateX(-50%) scale(0.95); bottom: 0; }
        .pos-center.speaking { transform: translateX(-50%) scale(1); }

        /* [대화창 UI] */
        .dialog-box {
            position: relative; width: 90%; max-width: 1000px; height: 200px;
            margin: 0 auto 30px auto; /* 하단 여백 */
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #fff; border-radius: 10px;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column;
            z-index: 100;
        }
        
        /* 이름표 */
        .name-tag {
            background: #e67e22; color: #fff;
            padding: 5px 20px; border-radius: 5px;
            font-weight: bold; font-size: 1.2em;
            position: absolute; top: -20px; left: 20px;
            border: 2px solid #fff;
        }

        /* 대사 텍스트 */
        .dialog-text {
            color: #fff; font-size: 1.4em; line-height: 1.6;
            margin-top: 10px; flex: 1;
        }
        
        /* 다음 넘기기 아이콘 */
        .next-indicator {
            position: absolute; bottom: 15px; right: 20px;
            color: #f1c40f; animation: blink 1s infinite;
            font-size: 1.5em; cursor: pointer;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* [선택지 UI] */
        #choice-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 200;
            display: none; flex-direction: column; justify-content: center; align-items: center; gap: 15px;
        }
        .choice-btn {
            background: #333; color: #fff; border: 2px solid #aaa;
            padding: 15px 40px; font-size: 1.2em; border-radius: 30px;
            cursor: pointer; transition: 0.2s; width: 60%; max-width: 500px;
        }
        .choice-btn:hover {
            background: #e67e22; border-color: #fff; transform: scale(1.05);
        }
    </style>
</head>
<body>

<div id="cutscene-layer" onclick="nextDialog()">
    
    <div id="standing-area" class="standing-area">
        </div>

    <div class="dialog-box">
        <div id="name-tag" class="name-tag">이름</div>
        <div id="dialog-text" class="dialog-text">대사가 여기에 출력됩니다.</div>
        <div class="next-indicator">▼</div>
    </div>

    <div id="choice-overlay">
        </div>
</div>

<script>
/* --- [1] 데이터 정의 --- */
// 시나리오 스크립트 (예시)
const SCENARIO_SCRIPT = [
    { type: "bg", src: "https://placehold.co/1920x1080/111/333?text=Night+City" },
    { type: "char", id: "detective", name: "탐정", src: "https://placehold.co/400x800/3498db/fff?text=Me", pos: "left" },
    { type: "char", id: "client", name: "의뢰인", src: "https://placehold.co/400x800/e74c3c/fff?text=Client", pos: "right" },
    
    { type: "talk", charId: "detective", text: "어서 오십시오. 미드나잇 탐정 사무소입니다." },
    { type: "talk", charId: "client", text: "......당신이 그 소문의 탐정이군요." },
    { type: "talk", charId: "detective", text: "무슨 일로 오셨습니까?" },
    { type: "talk", charId: "client", text: "제 동생이... '그곳'에 간 뒤로 돌아오지 않아요." },
    
    { type: "choice", options: [
        { txt: "자세한 이야기를 듣는다", next: 8 },
        { txt: "돈은 가져왔습니까?", next: 10 }
    ]},
    
    // 분기 A (8)
    { type: "talk", charId: "detective", text: "진정하시고 자세히 말씀해 보세요." },
    { type: "talk", charId: "client", text: "감사합니다... 사실 며칠 전부터 이상한 문자를 받았어요." },
    { type: "end" }, // 종료
    
    // 분기 B (10)
    { type: "talk", charId: "detective", text: "착수금은 준비해 오셨겠죠?" },
    { type: "talk", charId: "client", text: "물론입니다. 돈이라면 얼마든지 드릴 테니 제발..." },
    { type: "end" }
];

/* --- [2] 엔진 로직 --- */
let scriptIndex = 0;
let isTyping = false;
let currentText = "";
let typeInterval = null;

// 1. 캐릭터 관리
const characters = {}; // { id: element }

function updateCharacter(charId) {
    // 모든 캐릭터 어둡게
    for(let key in characters) {
        characters[key].classList.remove("speaking");
    }
    // 말하는 캐릭터만 밝게
    if (characters[charId]) {
        characters[charId].classList.add("speaking");
    } else {
        // 내레이션인 경우(charId가 없거나 null) -> 모두 어둡게 유지
    }
}

function showCharacter(id, name, src, pos) {
    // 이미 있으면 위치만 변경하거나 무시
    if (characters[id]) return;

    let img = document.createElement("img");
    img.src = src;
    img.className = `char-img ${pos}`; // pos-left, pos-right
    document.getElementById("standing-area").appendChild(img);
    
    characters[id] = img; // 저장
    // 이름도 데이터에 저장해두면 좋음 (여기선 생략)
}

// 2. 텍스트 타이핑 효과
function typeWriter(text) {
    const textBox = document.getElementById("dialog-text");
    textBox.innerHTML = "";
    currentText = text;
    isTyping = true;
    
    let i = 0;
    typeInterval = setInterval(() => {
        textBox.innerHTML += text.charAt(i);
        i++;
        if (i >= text.length) {
            finishTyping();
        }
    }, 30); // 속도 (ms)
}

function finishTyping() {
    clearInterval(typeInterval);
    document.getElementById("dialog-text").innerHTML = currentText;
    isTyping = false;
}

// 3. 스크립트 실행기 (메인)
function playNext() {
    if (scriptIndex >= SCENARIO_SCRIPT.length) return; // 끝
    
    let cmd = SCENARIO_SCRIPT[scriptIndex];

    // 배경 변경
    if (cmd.type === "bg") {
        document.getElementById("cutscene-layer").style.backgroundImage = `url('${cmd.src}')`;
        scriptIndex++;
        playNext(); // 바로 다음 명령 실행
    } 
    // 캐릭터 등장
    else if (cmd.type === "char") {
        showCharacter(cmd.id, cmd.name, cmd.src, `pos-${cmd.pos}`);
        scriptIndex++;
        playNext();
    }
    // 대화 출력
    else if (cmd.type === "talk") {
        // 이름표 갱신 (내레이션이면 숨김)
        let nameTag = document.getElementById("name-tag");
        if (cmd.charId) {
            // 이름 데이터가 스크립트 내에 없으면(첫 등장 아니면) SCENARIO_SCRIPT를 뒤져서 찾아야 함
            // 편의상 여기선 name 필드를 talk에도 넣거나, 별도 DB(CHAR_DATA)를 쓰는 게 좋음
            // 임시: 등장 시점의 데이터를 참조한다고 가정. (여기선 id를 그대로 출력하거나 하드코딩된 데이터 필요)
            // 예시를 위해 id를 대충 변환해서 출력
            let name = (cmd.charId === "detective") ? "탐정" : (cmd.charId === "client") ? "의뢰인" : "???";
            nameTag.innerText = name;
            nameTag.style.display = "block";
            updateCharacter(cmd.charId);
        } else {
            nameTag.style.display = "none";
            updateCharacter(null);
        }
        
        typeWriter(cmd.text);
        scriptIndex++; // 다음 인덱스로 (클릭 대기)
    }
    // 선택지
    else if (cmd.type === "choice") {
        showChoices(cmd.options);
        // 인덱스는 선택지 고른 후 점프함
    }
    // 종료
    else if (cmd.type === "end") {
        alert("컷신 종료! (게임 화면으로 전환)");
        // 여기서 switchScene('hub') 같은 걸 호출하면 됩니다.
    }
}

// 4. 입력 처리 (클릭)
function nextDialog() {
    // 선택지 창 떠있으면 클릭 무시
    if (document.getElementById("choice-overlay").style.display === "flex") return;

    // 타이핑 중이면 즉시 완료
    if (isTyping) {
        finishTyping();
        return;
    }

    // 다음 대사 재생
    playNext();
}

// 5. 선택지 표시
function showChoices(options) {
    const overlay = document.getElementById("choice-overlay");
    overlay.innerHTML = ""; // 초기화
    overlay.style.display = "flex";

    options.forEach(opt => {
        let btn = document.createElement("button");
        btn.className = "choice-btn";
        btn.innerText = opt.txt;
        btn.onclick = (e) => {
            e.stopPropagation(); // 배경 클릭 방지
            overlay.style.display = "none";
            
            // 분기 점프 (간단 구현: 배열 인덱스로 이동)
            // 실제로는 라벨(Label) 시스템이 더 좋지만, 여기선 배열 인덱스로 직접 이동
            scriptIndex = opt.next; 
            playNext();
        };
        overlay.appendChild(btn);
    });
}

// [시작]
window.onload = () => {
    playNext();
};
</script>
</body>
</html>